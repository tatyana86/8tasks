public class Main {

    static int xCur = -1; // координата x подматрицы с последней максимальнй суммой

    /* В функции реализован алгоритм Кадана.
       Функция получает  массив элементов, его размер и ограничение по количеству элементов.
       Возвращает наибольшую сумму m элементов. */
    public static int maxSubArray(int [] array, int n, int m) {
        int maxSum = Integer.MIN_VALUE; // максимальная сумма m элементов в массиве array
        if(m == 1) {
            return maxSum; // по условию 2 <= m <= n - 1
        }
        int curSum = 0; // текущая сумма элементов в массиве array
        int count = 0; // количество элементов, составляющих текущую сумму

        // считаем текущую сумму элементов для определения максимальной суммы m элементов
        for(int i = 0; i < n; i ++) {
            // в случае, если все элементы >= 0,
            // то в текущей сумме не учитывается минимальный из первого и последнего элементов
            // т.к. m <= n - 1
            if(count == n - 1 && array[i] > array[0]) {
                curSum += array[i] - array[0];
            }

            // в случае, если текущая сумма состоит из count < n - 1 элементов
            if(count < n - 1) {
                curSum += array[i]; // прибавляем к текущей сумме элемент
                count ++; // увеличиваем счетчик
            }

            // проверяем, что количество элементов равно размерности m
            if(count == m) {
                // сравниваем текущую сумму элементов с максимальной
                if(curSum > maxSum) {
                    maxSum = curSum; // если текущая больше, то записываем новую максимальную
                    xCur = i - m + 1; // запоминаем текущий для данного массива индкекс с максимальной суммой
                }
                // чтобы проверить другие комбинации из m элементов необходимо откинуть "первый" элемент
                // и уменьшить счетчик
                curSum -= array[i - m + 1];
                count --;
            }

            // в оригинальном алгоритме Кадана текущая сумма обнуляется, если становится отрицательной,
            // что не учитывает случай, когда исходный массив состоит только из отрицательных элементов;
            // чтобы учесть и такой случай, проверяем текущую сумму и текущий элемент
            if(curSum < array[i]) {
                curSum = array[i]; // текущая максимальная отрицательная сумма заменяется на больший отрицательный элемент
                count = 1;
            }
        }

        return maxSum;
    }

    public static void clearArray(int [] array) {
        for(int i = 0; i < array.length; i ++) {
            array[i] = 0;
        }
    }

    public static String army_communication_matrix(int n, int [][] matrix)  {
        int [] partialSum = new int[n]; // сумма элементов по столбцам от row до rowCur
        int maxSum = Integer.MIN_VALUE; // итоговая максимальная сумма подматрицы
        int m = 0; // размерность квадратной подматрицы
        int x = 0; // координата х верхнего левого элемента квадратной подматрицы
        int y = 0; // координата y верхнего левого элемента квадратной подматрицы

        // устанавливаем "верхнюю" границу рассматриваемой подматрицы
        for(int row = 0; row < n; row ++) {
            clearArray(partialSum); // очищаем старые значения
            // устанавливаем "нижнюю" границу рассматриваемой подматрицы
            for(int rowCur = row; rowCur < n; rowCur ++) {
                // считаем сумму элементов в столбцах выделенной подматрицы от row до curRow
                for(int col = 0; col < n; col ++) {
                    partialSum[col] += matrix[rowCur][col];
                }
                // считаем максимальную сумму в выделенной подматрице с учетом текущей высоты,
                // определяющей текущую размерность m квадратной подматрицы
                int curMaxSum = maxSubArray(partialSum, n, rowCur - row + 1);

                // проверяем, оказалась ли текущая максимальная сумма больше итоговой?
                if(curMaxSum > maxSum) {
                    maxSum = curMaxSum;
                    y = row;
                    x = xCur;
                    m = rowCur - row + 1;
                }
            }
        }

        return x + " " + y + " " + m;
    }

}